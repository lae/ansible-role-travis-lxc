---
# tasks file for lae.travis-lxc
- name: Identify python interpreter and merge container_config
  set_fact:
    ansible_python_interpreter: "{{ lookup('env', 'VIRTUAL_ENV') | default('/usr') }}/bin/python"
    container_config: "{{ container_config }} + {{ travis_lxc_network_config }}"

- name: Gather minimum subset of facts again with correct interpreter
  setup:
    gather_subset: "{{ 'min' if ansible_version.full is version_compare('2.4.0', '>=') else 'all' }}"

- include: validate_variables.yml
- include: travis_packaging_setup.yml

- name: Create SSH directory for current user
  file:
    path: "~{{ ansible_user_id }}/.ssh"
    state: directory
    mode: 0700

- name: Generate local ssh-rsa key
  command: "ssh-keygen -t rsa -N '' -C '{{ ansible_user_id }}@{{ ansible_hostname }}-lxctest' -f ~{{ ansible_user_id }}/.ssh/id_rsa"
  args:
    creates: "~{{ ansible_user_id }}/.ssh/id_rsa"

- block:
  - name: Extract all cached container root filesystems
    shell: "[ -f {{ __rootfs_tarball }} ] && tar -C / -I pigz -xf {{ __rootfs_tarball }}"
    async: 1800
    poll: 0
    changed_when: false
    register: __cache_restore_jobs
    args:
      warn: false
      creates: "{{ travis_lxc_profiles[item].rootfs }}"
    loop: "{{ lxc_cache_profiles }}"
    when: lxc_cache_enabled
    vars:
      __rootfs_tarball: "{{ lxc_cache_directory }}/{{ item }}.tar.gz"

  - name: Wait until cached root filesystems have been extracted
    async_status:
      jid: "{{ item.ansible_job_id }}"
    register: __cache_restore
    ignore_errors: true
    until: __cache_restore.finished
    retries: 100
    loop: "{{ __cache_restore_jobs.results }}"
    when: "lxc_cache_enabled and 'ansible_job_id' in item"

  - name: Prepare a single LXC container per profile as a base container
    lxc_container:
      name: "{{ item.prefix | default(__profile_data.prefix) }}base"
      template: "{{ __template }}"
      template_options: "\
        --release {{ __release }}
        {% if __template == 'debian' %}\
        --mirror http://deb.debian.org/debian
        {% elif __template == 'ubuntu' %}\
        --mirror {{ __travis_ubuntu_mirror }}
        {% endif %}\
        {% if __template not in ['centos', 'alpine'] %}\
        --packages {{ __packages | join(' ' if __template == 'fedora' else ',') }}
        {% elif __template == 'alpine' %}
        {{ __packages | join(' ') }}
        {% endif %}"
      container_config: "{{ container_config }}"
      state: stopped
    environment: "{{ __profile_data.environment | default({}) }}"
    register: __base_ct_jobs
    async: 7200
    poll: 0
    changed_when: false
    loop: "{{ test_profiles }}"
    vars:
      __template: "{{ item.profile.split('-').0 }}"
      __release: "{{ item.profile.split('-').1 }}"
      __profile_data: "{{ travis_lxc_profiles[item.profile] }}"
      __packages: "{{ __profile_data.packages + additional_packages }}"

  - name: Wait for base containers to finish bootstrapping
    async_status:
      jid: "{{ item.ansible_job_id }}"
    register: __base_cts
    until: __base_cts.finished
    retries: 300
    loop: "{{ __base_ct_jobs.results }}"

  - name: Install packages in containers using CentOS template
    lxc_container:
      name: "{{ item.lxc_container.name }}"
      container_command: "\
        until (ip addr show eth0 up | grep -q 'inet '); do sleep 1; done;
        yum install -y {{ __packages | join(' ') }}"
    register: __post_bootstrap_jobs
    async: 7200
    poll: 0
    changed_when: false
    loop: "{{ __base_cts.results }}"
    when:
      - item is changed
      - "item.invocation.module_args.template == 'centos'"
    vars:
      __packages: "{{ travis_lxc_profiles[item.item.item.profile].packages + additional_packages }}"

  - name: Wait for package installations to complete in CentOS containers
    async_status:
      jid: "{{ item.ansible_job_id }}"
    register: __post_bootstrap
    until: __post_bootstrap.finished
    retries: 300
    loop: "{{ __post_bootstrap_jobs.results }}"
    when: "'ansible_job_id' in item"

  - name: Configure local user with sudo and prepare authorized_keys files
    lxc_container:
      name: "{{ item.lxc_container.name }}"
      container_command: "\
        useradd -m {{ ansible_user_id }} -p aikatsu -s /bin/bash;
        printf '{{ ansible_user_id }} ALL=(ALL) NOPASSWD:ALL' > /etc/sudoers.d/{{ ansible_user_id }};
        mkdir -m 0700 /root/.ssh /home/{{ ansible_user_id }}/.ssh;
        touch /root/.ssh/authorized_keys /home/{{ ansible_user_id }}/.ssh/authorized_keys;
        chmod 0600 /root/.ssh/authorized_keys /home/{{ ansible_user_id }}/.ssh/authorized_keys;
        chown -R {{ ansible_user_id }}: /home/{{ ansible_user_id }}/.ssh"
    with_items: "{{ __base_cts.results }}"
    when:
      - item is changed

  # Ansible will throw the following warning:
  # [WARNING]: Cannot set fs attributes on a non-existent symlink target.
  # This must be ignored - the symlink points to a file that exists inside of
  # the container, not localhost
  - name: Enable SSH in Alpine
    file:
      src: "/etc/init.d/sshd"
      dest: "/var/lib/lxc/{{ item.lxc_container.name }}/rootfs/etc/runlevels/default/sshd"
      state: link
      force: yes
    loop: "{{ __base_cts.results }}"
    when: "item.invocation.module_args.template == 'alpine'"

  # Here we're identifying if any files, excepting those that match rootfs_exclude
  # in our profiles, have been modified since the environment was booted. If so,
  # or if we don't find a cached tarball for the profile we're executing on,
  # we'll create a compressed tarball using parallel gzip and setting all file
  # modification times to the unix epoch of the rootfs (w/o excludes).
  - name: Archive all container root filesystems
    shell: "
      modified_file_count=$(
        find {{ __rootfs }} -newermt \"$(uptime -s)\" -type f
          {% for path in __rootfs_exclude %}
          -not -path \"{{ __rootfs }}{{ path }}\"
          {% endfor %}
        | wc -l);
      [ $modified_file_count -gt 0 -o ! -f {{ __rootfs_tarball }} ] &&
      tar --mtime=@0 -I pigz
        {% for path in __rootfs_exclude %}
        --exclude=\"{{ __rootfs }}{{ path }}\"
        {% endfor %}
        -cf {{ __rootfs_tarball }} {{ __rootfs }} &&
      chown {{ ansible_user_id }}: {{ __rootfs_tarball }}"
    async: 1800
    poll: 0
    changed_when: false
    register: __cache_save_jobs
    args:
      warn: false
      creates: "{{ __rootfs_tarball }}"
    loop: "{{ lxc_cache_profiles }}"
    when: lxc_cache_enabled
    vars:
      __rootfs: "{{ travis_lxc_profiles[item].rootfs }}"
      __rootfs_exclude: "{{ travis_lxc_profiles[item].rootfs_exclude }}"
      __rootfs_tarball: "{{ lxc_cache_directory }}/{{ item }}.tar.gz"

  - name: Wait for all root filesystem archivals to complete
    async_status:
      jid: "{{ item.ansible_job_id }}"
    register: __cache_save
    ignore_errors: true
    until: __cache_save.finished
    retries: 100
    loop: "{{ __cache_save_jobs.results }}"
    when: "lxc_cache_enabled and 'ansible_job_id' in item"

  - name: Copy current user's public key into base containers
    copy:
      src: "~/.ssh/id_rsa.pub"
      dest: "/var/lib/lxc/{{ item.0.lxc_container.name }}/rootfs{{ item.1 }}"
    loop: "{{ __base_cts.results | product(__authorized_keys_paths) | list }}"
    vars:
      __authorized_keys_paths:
        - /root/.ssh/authorized_keys
        - "/home/{{ ansible_user_id }}/.ssh/authorized_keys"

  - name: Create all of our test LXC containers via cloning
    lxc_container:
      name: "{{ item.0.prefix | default(travis_lxc_profiles[item.0.profile].prefix) }}base"
      clone_name: "{{ item.0.prefix | default(travis_lxc_profiles[item.0.profile].prefix) }}{{ item.1 }}"
      clone_snapshot: "{{ True if lxc_use_overlayfs else False }}"
      backing_store: "{{ 'overlayfs' if lxc_use_overlayfs else 'dir' }}"
      state: stopped
    register: __clone_jobs
    async: 7200
    poll: 0
    changed_when: false
    loop: "{{ test_profiles | product(test_host_suffixes) | list }}"

  - name: Wait for all of the clone jobs to complete
    async_status:
      jid: "{{ item.ansible_job_id }}"
    register: __clone
    until: __clone.finished
    retries: 300
    loop: "{{ __clone_jobs.results }}"
    when: "'ansible_job_id' in item"

  - name: Start and wait for all test containers to come online
    lxc_container:
      name: "{{ item.invocation.module_args.clone_name }}"
      state: started
    register: __containers
    until: __containers.lxc_container.ips
    retries: 300
    loop: "{{ __clone.results }}"

  - name: Remove duplicate /dev/pts entries on CentOS 6
    lxc_container:
      name: "{{ item.invocation.module_args.clone_name }}"
      container_command: "\
        until [[ $(grep -c '/dev/pts ' /etc/mtab) -lt 2 ]]; do
          umount /dev/pts;
        done"
    with_items: "{{ __clone.results }}"
    when:
      - item is changed
      - "item.item.item.0.profile == 'centos-6'"

  - name: Collect all LXC container host information into one list
    set_fact:
      lxc_hosts: "[\
        {% for ct in (__containers.results | map(attribute='lxc_container') | list) %}\
        {'name': '{{ ct.name }}', 'ip': '{{ ct.ips[0] }}'}\
        {% if not loop.last %}, {% endif %}\
        {% endfor %}\
        ]"

  - name: Populate Travis' /etc/hosts with every container's addresses
    lineinfile:
      dest: /etc/hosts
      regexp: "^.* {{ item.name }}"
      line: "{{ item.ip }} {{ item.name }}.lxc {{ item.name }}"
    loop: "{{ lxc_hosts }}"

  - name: Populate every container's /etc/hosts with every container's addresses
    template:
      src: hosts.j2
      dest: "/var/lib/lxc/{{ item.name }}/{{ 'delta0' if lxc_use_overlayfs else 'rootfs' }}/etc/hosts"
    loop: "{{ lxc_hosts }}"
  become: True

- name: Collect SSH host keys from all containers
  shell: "ssh-keyscan {{ item.name }}.lxc {{ item.name }} > ~{{ ansible_user_id }}/.ssh/{{ item.name }}.pub"
  args:
    creates: "~{{ ansible_user_id }}/.ssh/{{ item.name }}.pub"
  loop: "{{ lxc_hosts }}"

- name: Add all containers to current user's known_hosts
  blockinfile:
    marker: "# {mark} {{ item.name }}"
    content: "{{ lookup('file', '~' + ansible_user_id + '/.ssh/' + item.name + '.pub') }}"
    dest: "~{{ ansible_user_id }}/.ssh/known_hosts"
    create: yes
  loop: "{{ lxc_hosts }}"

# vim:ft=ansible:
