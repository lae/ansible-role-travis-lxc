---
# tasks file for ansible-role-travis-lxc
- set_fact:
    ansible_python_interpreter: "{{ lookup('env', 'VIRTUAL_ENV') }}/bin/python"
    container_config: "{{ container_config }} + {{ travis_lxc_network_config }}"

- include: validate_variables.yml
- include: travis_packaging_setup.yml

- name: Create SSH directory for current user
  file:
    path: "~{{ ansible_user_id }}/.ssh"
    state: directory
    mode: 0700

- name: Generate local ssh-rsa key
  user:
    name: "{{ ansible_user_id }}"
    generate_ssh_key: true
    ssh_key_file: "~{{ ansible_user_id }}/.ssh/id_rsa"
    ssh_key_type: rsa
    ssh_key_comment: "{{ ansible_user_id }}@{{ ansible_hostname }}-lxctest"

- block:
  - name: Extract all cached container root filesystems
    shell: "tar -C / -xf {{ __rootfs_tarball }} && rm {{ __rootfs_tarball }}"
    async: 1800
    poll: 0
    changed_when: false
    register: __cache_restore_jobs
    args:
      warn: false
      creates: "{{ travis_lxc_profiles[item].rootfs }}"
      removes: "{{ __rootfs_tarball }}"
    with_items: "{{ lxc_cache_profiles }}"
    when: lxc_cache_enabled
    vars:
      __rootfs_tarball: "{{ lxc_cache_directory }}/{{ item }}.tar"

  - name: Wait until cached root filesystems have been extracted
    async_status:
      jid: "{{ item.ansible_job_id }}"
    register: __cache_restore
    ignore_errors: true
    until: __cache_restore.finished
    with_items: "{{ __cache_restore_jobs.results }}"
    when: "lxc_cache_enabled and 'ansible_job_id' in item"

  - name: Prepare a single LXC container per profile as a base container
    lxc_container:
      name: "{{ item.prefix | default(item.profile) }}"
      template: "{{ __template }}"
      template_options: "\
        --release {{ __release }}
        {% if __template == 'debian' %}\
        --mirror http://deb.debian.org/debian
        {% elif __template == 'ubuntu' %}\
        --mirror {{ __travis_ubuntu_mirror }}
        {% endif %}\
        {% if __template != 'centos' %}\
        --packages {{ __packages | join(' ' if __template == 'fedora' else ',') }}
        {% endif %}"
      container_config: "{{ container_config }}"
      state: stopped
    environment: "{{ travis_lxc_profiles[item.profile].environment | default({}) }}"
    register: __base_ct_jobs
    async: 7200
    poll: 0
    changed_when: false
    with_items:
      - "{{ test_profiles }}"
    vars:
      __template: "{{ item.profile.split('-').0 }}"
      __release: "{{ item.profile.split('-').1 }}"
      __packages: "{{ travis_lxc_profiles[item.profile].packages + additional_packages }}"

  - name: Wait for base containers to finish bootstrapping
    async_status:
      jid: "{{ item.ansible_job_id }}"
    register: __base_cts
    until: __base_cts.finished
    retries: 300
    with_items: "{{ __base_ct_jobs.results }}"

  - name: Install packages in containers using the CentOS template
    lxc_container:
      name: "{{ item.lxc_container.name }}"
      container_command: "\
        until (ip addr show eth0 up | grep -q 'inet '); do sleep 1; done;
        yum install -y {{ (travis_lxc_profiles[item.item.item.profile].packages + additional_packages) | join(' ') }}"
    register: __post_bootstrap_jobs
    async: 7200
    poll: 0
    changed_when: false
    with_items: "{{ __base_cts.results }}"
    when:
      - item | changed
      - "item.invocation.module_args.template == 'centos'"

  - name: Wait for package installations to complete in CentOS containers
    async_status:
      jid: "{{ item.ansible_job_id }}"
    register: __post_bootstrap
    until: __post_bootstrap.finished
    retries: 300
    with_items: "{{ __post_bootstrap_jobs.results }}"
    when: "'ansible_job_id' in item"

  - name: Archive all container root filesystems
    shell: "tar --mtime=0 -cf {{ __rootfs_tarball }} {{ travis_lxc_profiles[item].rootfs }} && chown {{ ansible_user_id }}: {{ lxc_cache_directory }}/{{ item }}.tar"
    async: 1800
    poll: 0
    changed_when: false
    register: __cache_save_jobs
    args:
      warn: false
      creates: "{{ __rootfs_tarball }}"
    with_items: "{{ lxc_cache_profiles }}"
    when: lxc_cache_enabled
    vars:
      __rootfs_tarball: "{{ lxc_cache_directory }}/{{ item }}.tar"

  - name: Wait for all root filesystem archivals to complete
    async_status:
      jid: "{{ item.ansible_job_id }}"
    register: __cache_save
    ignore_errors: true
    until: __cache_save.finished
    retries: 100
    with_items: "{{ __cache_save_jobs.results }}"
    when: "lxc_cache_enabled and 'ansible_job_id' in item"

  - name: Create an .ssh directory in the base containers
    file:
      path: "/var/lib/lxc/{{ item.lxc_container.name }}/rootfs/root/.ssh/"
      state: directory
      mode: 0700
    with_items: "{{ __base_cts.results }}"

  - name: Copy current user's public key into base containers
    copy:
      src: "~/.ssh/id_rsa.pub"
      dest: "/var/lib/lxc/{{ item.lxc_container.name }}/rootfs/root/.ssh/authorized_keys"
      mode: 0600
    with_items: "{{ __base_cts.results }}"

  - name: Create all of our test LXC containers via cloning
    lxc_container:
      name: "{{ item.0.prefix | default(item.0.profile) }}"
      clone_name: "{{ item.0.prefix | default(item.0.profile) }}{{ item.1 }}"
      clone_snapshot: true
      backing_store: overlayfs
      state: stopped
    register: __clone_jobs
    async: 7200
    poll: 0
    changed_when: false
    with_nested:
      - "{{ test_profiles }}"
      - "{{ test_host_suffixes }}"

  - name: Wait for all of the clone jobs to complete
    async_status:
      jid: "{{ item.ansible_job_id }}"
    register: __clone
    until: __clone.finished
    retries: 300
    with_items: "{{ __clone_jobs.results }}"
    when: "'ansible_job_id' in item"

  - name: Bring up all of the test LXC containers
    lxc_container:
      name: "{{ item.invocation.module_args.clone_name }}"
      state: started
    register: __containers
    with_items: "{{ __clone.results }}"

  - name: Wait for network connectivity on all containers
    lxc_container:
      name: "{{ item.lxc_container.name }}"
      container_command: "until (ip addr show eth0 up | grep -q 'inet '); do sleep 1; done"
    register: __container_addresses
    changed_when: false
    with_items: "{{ __containers.results }}"

  - set_fact:
      lxc_hosts: "[\
        {% for ct in (__container_addresses.results | map(attribute='lxc_container') | list) %}\
        {'name': '{{ ct.name }}', 'ip': '{{ ct.ips[0] }}'}\
        {% if not loop.last %}, {% endif %}\
        {% endfor %}\
        ]"

  - name: Populate Travis' /etc/hosts with every container's addresses
    lineinfile:
      dest: /etc/hosts
      regexp: "^.* {{ item.name }}"
      line: "{{ item.ip }} {{ item.name }}.lxc {{ item.name }}"
    with_items: "{{ lxc_hosts }}"

  - name: Populate every container's /etc/hosts with every container's addresses
    template:
      src: hosts.j2
      dest: "/var/lib/lxc/{{ item.name }}/delta0/etc/hosts"
    with_items: "{{ lxc_hosts }}"

  become: true

- name: Collect SSH host keys from all containers
  shell: "ssh-keyscan {{ item.name }}.lxc {{ item.name }} > ~{{ ansible_user_id }}/.ssh/{{ item.name }}.pub"
  args:
    creates: "~{{ ansible_user_id }}/.ssh/{{ item.name }}.pub"
  with_items: "{{ lxc_hosts }}"

- name: Add all containers to current user's known_hosts
  blockinfile:
    marker: "# {mark} {{ item.name }}"
    content: "{{ lookup('file', '~' + ansible_user_id + '/.ssh/' + item.name + '.pub') }}"
    dest: "~{{ ansible_user_id }}/.ssh/known_hosts"
    create: yes
  with_items: "{{ lxc_hosts }}"

# vim:ft=ansible:
