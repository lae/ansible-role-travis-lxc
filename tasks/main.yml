---
# tasks file for lae.travis-lxc
- set_fact:
    ansible_python_interpreter: "{{ lookup('env', 'VIRTUAL_ENV') }}/bin/python"
    container_config: "{{ container_config }} + {{ travis_lxc_network_config }}"

- include: validate_variables.yml
- include: travis_packaging_setup.yml

- name: Create SSH directory for current user
  file:
    path: "~{{ ansible_user_id }}/.ssh"
    state: directory
    mode: 0700

- name: Generate local ssh-rsa key
  user:
    name: "{{ ansible_user_id }}"
    generate_ssh_key: true
    ssh_key_file: "~{{ ansible_user_id }}/.ssh/id_rsa"
    ssh_key_type: rsa
    ssh_key_comment: "{{ ansible_user_id }}@{{ ansible_hostname }}-lxctest"

- block:
  - name: Extract all cached container root filesystems
    shell: "[ -f {{ __rootfs_tarball }} ] && tar -C / -I pigz -xf {{ __rootfs_tarball }}"
    async: 1800
    poll: 0
    changed_when: false
    register: __cache_restore_jobs
    args:
      warn: false
      creates: "{{ travis_lxc_profiles[item].rootfs }}"
    with_items: "{{ lxc_cache_profiles }}"
    when: lxc_cache_enabled
    vars:
      __rootfs_tarball: "{{ lxc_cache_directory }}/{{ item }}.tar.gz"

  - name: Wait until cached root filesystems have been extracted
    async_status:
      jid: "{{ item.ansible_job_id }}"
    register: __cache_restore
    ignore_errors: true
    until: __cache_restore.finished
    retries: 100
    with_items: "{{ __cache_restore_jobs.results }}"
    when: "lxc_cache_enabled and 'ansible_job_id' in item"

  - name: Prepare a single LXC container per profile as a base container
    lxc_container:
      name: "{{ item.prefix | default(__profile_data.prefix) }}base"
      template: "{{ __template }}"
      template_options: "\
        --release {{ __release }}
        {% if __template == 'debian' %}\
        --mirror http://deb.debian.org/debian
        {% elif __template == 'ubuntu' %}\
        --mirror {{ __travis_ubuntu_mirror }}
        {% endif %}\
        {% if __template not in ['centos', 'alpine'] %}\
        --packages {{ __packages | join(' ' if __template == 'fedora' else ',') }}
        {% endif %}"
      container_config: "{{ container_config }}"
      state: stopped
    environment: "{{ __profile_data.environment | default({}) }}"
    register: __base_ct_jobs
    async: 7200
    poll: 0
    changed_when: false
    with_items:
      - "{{ test_profiles }}"
    vars:
      __template: "{{ item.profile.split('-').0 }}"
      __release: "{{ item.profile.split('-').1 }}"
      __profile_data: "{{ travis_lxc_profiles[item.profile] }}"
      __packages: "{{ __profile_data.packages + additional_packages }}"

  - name: Wait for base containers to finish bootstrapping
    async_status:
      jid: "{{ item.ansible_job_id }}"
    register: __base_cts
    until: __base_cts.finished
    retries: 300
    with_items: "{{ __base_ct_jobs.results }}"

  - name: Install packages in containers using templates that don't support extra package installation
    lxc_container:
      name: "{{ item.lxc_container.name }}"
      container_command: "\
        until (ip addr show eth0 up | grep -q 'inet '); do sleep 1; done;
        {% if __template == 'centos' %}yum install -y{% endif %}
        {% if __template == 'alpine' %}apk add --no-cache{% endif %}
        {{ (travis_lxc_profiles[item.item.item.profile].packages + additional_packages) | join(' ') }}"
    register: __post_bootstrap_jobs
    async: 7200
    poll: 0
    changed_when: false
    with_items: "{{ __base_cts.results }}"
    when:
      - item | changed
      - "__template in ['centos', 'alpine']"
    vars:
      __template: "{{ item.invocation.module_args.template }}"

  - name: Wait for package installations to complete in CentOS containers
    async_status:
      jid: "{{ item.ansible_job_id }}"
    register: __post_bootstrap
    until: __post_bootstrap.finished
    retries: 300
    with_items: "{{ __post_bootstrap_jobs.results }}"
    when: "'ansible_job_id' in item"

  # Here we're identifying if any files, excepting those that match rootfs_exclude
  # in our profiles, have been modified since the environment was booted. If so,
  # or if we don't find a cached tarball for the profile we're executing on,
  # we'll create a compressed tarball using parallel gzip and setting all file
  # modification times to the unix epoch of the rootfs (w/o excludes).
  - name: Archive all container root filesystems
    shell: "
      modified_file_count=$(
        find {{ __rootfs }} -newermt \"$(uptime -s)\" -type f
          {% for path in __rootfs_exclude %}
          -not -path \"{{ __rootfs }}{{ path }}\"
          {% endfor %}
        | wc -l);
      [ $modified_file_count -gt 0 -o ! -f {{ __rootfs_tarball }} ] &&
      tar --mtime=@0 -I pigz
        {% for path in __rootfs_exclude %}
        --exclude=\"{{ __rootfs }}{{ path }}\"
        {% endfor %}
        -cf {{ __rootfs_tarball }} {{ __rootfs }} &&
      chown {{ ansible_user_id }}: {{ __rootfs_tarball }}"
    async: 1800
    poll: 0
    changed_when: false
    register: __cache_save_jobs
    args:
      warn: false
      creates: "{{ __rootfs_tarball }}"
    with_items: "{{ lxc_cache_profiles }}"
    when: lxc_cache_enabled
    vars:
      __rootfs: "{{ travis_lxc_profiles[item].rootfs }}"
      __rootfs_exclude: "{{ travis_lxc_profiles[item].rootfs_exclude }}"
      __rootfs_tarball: "{{ lxc_cache_directory }}/{{ item }}.tar.gz"

  - name: Wait for all root filesystem archivals to complete
    async_status:
      jid: "{{ item.ansible_job_id }}"
    register: __cache_save
    ignore_errors: true
    until: __cache_save.finished
    retries: 100
    with_items: "{{ __cache_save_jobs.results }}"
    when: "lxc_cache_enabled and 'ansible_job_id' in item"

  - name: Create an .ssh directory in the base containers
    file:
      path: "/var/lib/lxc/{{ item.lxc_container.name }}/rootfs/root/.ssh/"
      state: directory
      mode: 0700
    with_items: "{{ __base_cts.results }}"

  - name: Copy current user's public key into base containers
    copy:
      src: "~/.ssh/id_rsa.pub"
      dest: "/var/lib/lxc/{{ item.lxc_container.name }}/rootfs/root/.ssh/authorized_keys"
      mode: 0600
    with_items: "{{ __base_cts.results }}"

  - name: Create all of our test LXC containers via cloning
    lxc_container:
      name: "{{ item.0.prefix | default(travis_lxc_profiles[item.0.profile].prefix) }}base"
      clone_name: "{{ item.0.prefix | default(travis_lxc_profiles[item.0.profile].prefix) }}{{ item.1 }}"
      clone_snapshot: "{{ True if lxc_use_overlayfs else False }}"
      backing_store: "{{ 'overlayfs' if lxc_use_overlayfs else 'dir' }}"
      state: stopped
    register: __clone_jobs
    async: 7200
    poll: 0
    changed_when: false
    with_nested:
      - "{{ test_profiles }}"
      - "{{ test_host_suffixes }}"

  - name: Wait for all of the clone jobs to complete
    async_status:
      jid: "{{ item.ansible_job_id }}"
    register: __clone
    until: __clone.finished
    retries: 300
    with_items: "{{ __clone_jobs.results }}"
    when: "'ansible_job_id' in item"

  - name: Bring up all of the test LXC containers
    lxc_container:
      name: "{{ item.invocation.module_args.clone_name }}"
      state: started
    register: __containers
    with_items: "{{ __clone.results }}"

  - name: Wait for network connectivity on all containers
    lxc_container:
      name: "{{ item.lxc_container.name }}"
      container_command: "until (ip addr show eth0 up | grep -q 'inet '); do sleep 1; done"
    register: __container_addresses
    changed_when: false
    with_items: "{{ __containers.results }}"

  - set_fact:
      lxc_hosts: "[\
        {% for ct in (__container_addresses.results | map(attribute='lxc_container') | list) %}\
        {'name': '{{ ct.name }}', 'ip': '{{ ct.ips[0] }}'}\
        {% if not loop.last %}, {% endif %}\
        {% endfor %}\
        ]"

  - name: Populate Travis' /etc/hosts with every container's addresses
    lineinfile:
      dest: /etc/hosts
      regexp: "^.* {{ item.name }}"
      line: "{{ item.ip }} {{ item.name }}.lxc {{ item.name }}"
    with_items: "{{ lxc_hosts }}"

  - name: Populate every container's /etc/hosts with every container's addresses
    template:
      src: hosts.j2
      dest: "/var/lib/lxc/{{ item.name }}/{{ 'delta0' if lxc_use_overlayfs else 'rootfs' }}/etc/hosts"
    with_items: "{{ lxc_hosts }}"

  become: true

- name: Collect SSH host keys from all containers
  shell: "ssh-keyscan {{ item.name }}.lxc {{ item.name }} > ~{{ ansible_user_id }}/.ssh/{{ item.name }}.pub"
  args:
    creates: "~{{ ansible_user_id }}/.ssh/{{ item.name }}.pub"
  with_items: "{{ lxc_hosts }}"

- name: Add all containers to current user's known_hosts
  blockinfile:
    marker: "# {mark} {{ item.name }}"
    content: "{{ lookup('file', '~' + ansible_user_id + '/.ssh/' + item.name + '.pub') }}"
    dest: "~{{ ansible_user_id }}/.ssh/known_hosts"
    create: yes
  with_items: "{{ lxc_hosts }}"

# vim:ft=ansible:
