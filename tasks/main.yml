---
# tasks file for ansible-role-travis-lxc
- set_fact:
    ansible_python_interpreter: "{{ lookup('env', 'VIRTUAL_ENV') }}/bin/python"
    container_config: "{{ container_config }} + {{ travis_lxc_network_config }}"

- include: validate_variables.yml
- include: travis_packaging_setup.yml

- name: Create SSH directory for current user
  file:
    path: "~{{ ansible_user_id }}/.ssh"
    state: directory
    mode: 0700

- name: Generate local ssh-rsa key
  user:
    name: "{{ ansible_user_id }}"
    generate_ssh_key: true
    ssh_key_file: "~{{ ansible_user_id }}/.ssh/id_rsa"
    ssh_key_type: rsa
    ssh_key_comment: "{{ ansible_user_id }}@{{ ansible_hostname }}-lxctest"

- block:
  - name: Create initial LXC containers for requested test profiles
    lxc_container:
      name: "{{ item.prefix | default(item.profile) }}{{ test_host_suffixes.0 }}"
      template: "{{ item.profile.split('-').0 }}"
      template_options: >-
        {% set __os = item.profile.split('-') %}
        --release {{ __os.1 }}
        {% if __os.0 in ['debian', 'ubuntu'] %}
        --mirror
        {% if __os.0 == 'ubuntu' %}
        {{ __travis_ubuntu_mirror }}
        {% else %}
        http://deb.debian.org/debian
        {% endif %}
        --packages {{ (travis_lxc_profiles[item.profile].packages + additional_packages) | join(',') }}
        {% endif %}
      container_config: "{{ container_config }}"
      state: started
    environment: "{{ travis_lxc_profiles[item.profile].environment | default({}) }}"
    register: __container_creation_jobs
    async: 7200
    poll: 0
    changed_when: false
    with_items:
      - "{{ test_profiles }}"

  - name: Wait for container creation tasks to complete
    async_status:
      jid: "{{ item.ansible_job_id }}"
    register: __initial_containers
    until: __initial_containers.finished
    retries: 300
    with_items: "{{ __container_creation_jobs.results }}"

  - name: Wait until initial containers have active IP addresses
    lxc_container:
      name: "{{ item.lxc_container.name }}"
      container_command: "until (ip addr show eth0 up | grep -q 'inet '); do sleep 1; done"
    changed_when: false
    with_items: "{{ __initial_containers.results }}"

  - name: Install packages in RHEL-based containers
    lxc_container:
      name: "{{ item.lxc_container.name }}"
      container_command: >-
        {% if item.invocation.module_args.template == 'fedora' %}
        dnf install -y
        {% else %}
        yum install -y
        {% endif %}
        {{ (travis_lxc_profiles[item.item.item.profile].packages + additional_packages) | join(' ') }}
    register: __container_post_jobs
    async: 7200
    poll: 0
    changed_when: false
    with_items: "{{ __initial_containers.results }}"
    when:
      - item | changed
      - "item.invocation.module_args.template is in ['centos', 'fedora']"

  - name: Wait for RHEL package installations to complete
    async_status:
      jid: "{{ item.ansible_job_id }}"
    register: __async_status
    until: __async_status.finished
    retries: 300
    with_items: "{{ __container_post_jobs.results }}"
    when: "'ansible_job_id' in item"

  - name: Create remaining LXC containers via clone
    lxc_container:
      name: "{{ item.0.prefix | default(item.0.profile) }}{{ test_host_suffixes.0 }}"
      clone_name: "{{ item.0.prefix | default(item.0.profile) }}{{ item.1 }}"
    register: __container_clone_jobs
    async: 7200
    poll: 0
    changed_when: false
    with_nested:
      - "{{ test_profiles }}"
      - "{{ test_host_suffixes[1:] }}"

  - name: Wait for container clone tasks to complete
    async_status:
      jid: "{{ item.ansible_job_id }}"
    register: __containers
    until: __containers.finished
    retries: 300
    with_items: "{{ __container_clone_jobs.results }}"

  - name: Ensure all containers are started
    lxc_container:
      name: "{{ item.lxc_container.name }}"
      state: started
    changed_when: false
    with_items: "{{ __containers.results }}"

  - name: Wait until all containers have active IP addresses
    lxc_container:
      name: "{{ item.lxc_container.name }}"
      container_command: "until (ip addr show eth0 up | grep -q 'inet '); do sleep 1; done"
    register: __container_addresses
    changed_when: false
    with_items: "{{ __containers.results }}"

  - debug:
      var: __containers
      verbosity: 2

  - debug:
      var: __container_addresses
      verbosity: 2

  - set_fact:
      lxc_hosts: "{% set __hosts = [] %}{% for ct in (__container_addresses.results | map(attribute='lxc_container') | list) %}{{ __hosts.append({'name': ct.name, 'ip': ct.ips[0]}) }}{% endfor %}{{ __hosts }}"

  - name: Populate Travis' /etc/hosts with every container's addresses
    lineinfile:
      dest: /etc/hosts
      regexp: "^.* {{ item.name }}"
      line: "{{ item.ip }} {{ item.name }}.lxc {{ item.name }}"
    with_items: "{{ lxc_hosts }}"

  - name: Populate every container's /etc/hosts with every container's addresses
    template:
      src: hosts.j2
      dest: "/var/lib/lxc/{{ item.name }}/rootfs/etc/hosts"
    with_items: "{{ lxc_hosts }}"

  - name: Create .ssh directory in containers
    file:
      path: "/var/lib/lxc/{{ item.name }}/rootfs/root/.ssh/"
      state: directory
      mode: 0700
    with_items: "{{ lxc_hosts }}"

  - name: Copy current user's public key into containers
    copy:
      src: "~/.ssh/id_rsa.pub"
      dest: "/var/lib/lxc/{{ item.name }}/rootfs/root/.ssh/authorized_keys"
      mode: 0600
    with_items: "{{ lxc_hosts }}"
  become: true

- name: Collect SSH host keys from all containers
  shell: "ssh-keyscan {{ item.name }}.lxc {{ item.name }} > ~{{ ansible_user_id }}/.ssh/{{ item.name }}.pub"
  args:
    creates: "~{{ ansible_user_id }}/.ssh/{{ item.name }}.pub"
  with_items: "{{ lxc_hosts }}"

- name: Add all containers to current user's known_hosts
  blockinfile:
    marker: "# {mark} {{ item.name }}"
    content: "{{ lookup('file', '~' + ansible_user_id + '/.ssh/' + item.name + '.pub') }}"
    dest: "~{{ ansible_user_id }}/.ssh/known_hosts"
    create: yes
  with_items: "{{ lxc_hosts }}"

# vim:ft=ansible:
